package info.eecc.intellipack.epcat;

import info.eecc.commons.epcis.builder.EpcisDocumentBuilder;
import info.eecc.commons.epcis.core.EpcisDocument;
import info.eecc.commons.epcis.core.EpcisEvent;
import info.eecc.commons.epcis.writer.EpcisModelXmlWriter;
import info.eecc.intellipack.epcis.extensions.IntellipackExtension;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.http.client.ClientHttpRequestFactory;
import org.springframework.http.client.SimpleClientHttpRequestFactory;
import org.springframework.util.Assert;
import org.springframework.web.client.RestTemplate;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Developer: Sabrina Meier
 * Company: EECC
 * Created: 27.07.2021
 */
public class EpcatEventSender {

    private static final Logger LOGGER = LoggerFactory.getLogger(EpcatEventSender.class);

    private final EpcatProperties epcatProperties;

    private final String url;

    private EpcisModelXmlWriter writer;

    EpcatEventSender(EpcatProperties epcatProperties) {
        Assert.hasText(epcatProperties.getUrl(), "EPCAT url may not be empty");

        this.epcatProperties = epcatProperties;
        this.url = epcatProperties.getUrl() + "/capture";
        this.writer = EpcisModelXmlWriter.withExtensions(new IntellipackExtension()); //Here withExtensions
    }


    public ResponseEntity<String> postEvents(List<EpcisEvent> events, String traceId) {
        EpcisDocumentBuilder docBuilder = new EpcisDocumentBuilder();
        docBuilder.addAll(events);
        EpcisDocument document = docBuilder.build();

        String xmlDocument = writer.writeToString(document.cast());

        HttpHeaders headers = new HttpHeaders();
        headers.set("Content-Type", "text/xml;charset=UTF-8");
        if (traceId != null && !traceId.isEmpty()) headers.set("X-EECC-Trace-Id", traceId);
        headers.setAccept(Collections.singletonList(MediaType.TEXT_XML));

        HttpEntity<String> requestEntity = new HttpEntity<>(xmlDocument, headers);

        RestTemplate restTemplate = new RestTemplate();

        ClientHttpRequestFactory factory = restTemplate.getRequestFactory();

        if (factory instanceof SimpleClientHttpRequestFactory) {
            ((SimpleClientHttpRequestFactory) factory).setConnectTimeout((int) epcatProperties.getConnectionTimeoutInSeconds() * 1000);
            ((SimpleClientHttpRequestFactory) factory).setReadTimeout((int) epcatProperties.getReadTimeoutInSeconds() * 1000);
        }

        restTemplate.setRequestFactory(factory);

        return restTemplate.postForEntity(url, requestEntity, String.class);
    }

    /*
     Poor man's xml parsing.

     Example:
    "...<capturedEventIds><eventId>33b147ce-04b4-476f-81cf-93379e033a9d</eventId><eventId>bf1bec51-617f-4e4b-88b5-a501cca299b9</eventId></capturedEventIds>..."
    -> ["33b147ce-04b4-476f-81cf-93379e033a9d", "bf1bec51-617f-4e4b-88b5-a501cca299b9"]

    Returns empty list if no event ids are found.
    */
    public static List<String> parseEventIdsFromEpcatAnswer(String epcatAnswer) {
        List<String> re = new ArrayList<>();

        Matcher m = Pattern
            .compile(".*(<capturedEventIds>.*</capturedEventIds>).*")
            .matcher(epcatAnswer);
        if (!m.find() || m.groupCount() < 1) {
            return re;
        }

        m = Pattern
            .compile("<capturedEventIds>(<eventId>[^<]*</eventId>)(.*)")
            .matcher(m.group(1));
        while (m.find() && m.groupCount() > 0) {
            re.add(m.group(1).substring(9, m.group(1).length() - 10));
            m = Pattern
                .compile("(<eventId>[^<]*</eventId>)(.*)")
                .matcher(m.group(2));
        }
        LOGGER.debug("Event IDs generated by Epcat: {}", re);
        return re;
    }
}
